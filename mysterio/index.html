<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Songs for the Simulation - Mysterio</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0a0a0f;
    }
    #root {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script type="text/babel">
    class Domain {
      constructor(id, name, config, availablePortals) {
        this.id = id;
        this.name = name;
        this.bg = config.bg;
        this.primary = config.primary;
        this.secondary = config.secondary;
        this.accent = config.accent;
        this.particleCount = config.particleCount;
        this.availablePortals = availablePortals;
      }
    }

    const portalConfigs = {
      1: { type: 'cube', color: '#00ffff', size: 60, animation: 'rotate' },
      2: { type: 'sphere', color: '#ff0080', size: 70, animation: 'pulse' },
      3: { type: 'pyramid', color: '#00ff00', size: 65, animation: 'float' }
    };

    const SimulationSpaces = () => {
      const { useState, useEffect, useRef } = React;

      const domains = useRef({
        1: new Domain(1, 'void', {
          bg: '#0a0a0f', primary: '#00ffff', secondary: '#0080ff',
          accent: '#00ffff', particleCount: 50
        }, [2, 3]),
        2: new Domain(2, 'lattice', {
          bg: '#0f0a0f', primary: '#ff0080', secondary: '#ff00ff',
          accent: '#ff0080', particleCount: 55
        }, [1, 3]),
        3: new Domain(3, 'cascade', {
          bg: '#0a0f0a', primary: '#00ff00', secondary: '#80ff00',
          accent: '#00ff00', particleCount: 52
        }, [1, 2])
      }).current;

      const [currentDomainId, setCurrentDomainId] = useState(1);
      const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });
      const [transitioning, setTransitioning] = useState(false);
      const [cameraPos, setCameraPos] = useState({ x: 0, y: 0, z: 0 });
      const canvasRef = useRef(null);
      const particlesRef = useRef([]);
      const portalsRef = useRef([]);

      const currentDomain = domains[currentDomainId];

      useEffect(() => {
        particlesRef.current = Array.from({ length: currentDomain.particleCount }, () => ({
          x: (Math.random() - 0.5) * 4,
          y: (Math.random() - 0.5) * 4,
          z: Math.random() * 8 + 2,
          baseSpeed: 0.001 + Math.random() * 0.002
        }));

        portalsRef.current = currentDomain.availablePortals.map((portalId, index) => {
          const angle = (index / currentDomain.availablePortals.length) * Math.PI * 2;
          const distance = 6 + Math.random() * 2;
          return {
            id: portalId,
            x: Math.cos(angle) * distance * 0.7,
            y: Math.sin(angle) * distance * 0.5,
            z: distance,
            config: portalConfigs[portalId]
          };
        });
      }, [currentDomainId]);

      useEffect(() => {
        const handleMouseMove = (e) => {
          setMousePos({
            x: e.clientX / window.innerWidth,
            y: e.clientY / window.innerHeight
          });
        };
        window.addEventListener('mousemove', handleMouseMove);
        return () => window.removeEventListener('mousemove', handleMouseMove);
      }, []);

      useEffect(() => {
        const interval = setInterval(() => {
          setCameraPos(prev => ({
            x: prev.x + (mousePos.x - 0.5) * 0.015,
            y: prev.y + (mousePos.y - 0.5) * 0.015,
            z: prev.z + 0.02
          }));
        }, 16);
        return () => clearInterval(interval);
      }, [mousePos]);

      const handlePortalClick = (portal) => {
        if (transitioning) return;
        const dx = portal.x - cameraPos.x;
        const dy = portal.y - cameraPos.y;
        const dz = portal.z - cameraPos.z;
        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        
        if (distance < 2) {
          setTransitioning(true);
          setTimeout(() => {
            setCurrentDomainId(portal.id);
            setCameraPos({ x: 0, y: 0, z: 0 });
            setTransitioning(false);
          }, 800);
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const resize = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        };
        resize();
        window.addEventListener('resize', resize);

        let animationId;
        const animate = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;

          particlesRef.current.forEach(p => {
            if (p.z < cameraPos.z - 1) {
              p.z = cameraPos.z + 8;
              p.x = (Math.random() - 0.5) * 4;
              p.y = (Math.random() - 0.5) * 4;
            }

            const relX = p.x - cameraPos.x;
            const relY = p.y - cameraPos.y;
            const relZ = p.z - cameraPos.z;
            if (relZ <= 0) return;

            const scale = 400 / relZ;
            const screenX = centerX + relX * scale;
            const screenY = centerY + relY * scale;
            const size = scale * 0.8;
            const opacity = Math.min(1, 3 / relZ);

            ctx.fillStyle = `${currentDomain.primary}${Math.floor(opacity * 180).toString(16).padStart(2, '0')}`;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
            ctx.fill();

            particlesRef.current.forEach(other => {
              if (other === p) return;
              const dist3D = Math.sqrt(
                Math.pow(p.x - other.x, 2) +
                Math.pow(p.y - other.y, 2) +
                Math.pow(p.z - other.z, 2)
              );

              if (dist3D < 1.5) {
                const otherRelX = other.x - cameraPos.x;
                const otherRelY = other.y - cameraPos.y;
                const otherRelZ = other.z - cameraPos.z;
                if (otherRelZ <= 0) return;

                const otherScale = 400 / otherRelZ;
                const otherScreenX = centerX + otherRelX * otherScale;
                const otherScreenY = centerY + otherRelY * otherScale;
                const lineOpacity = Math.min(opacity, 3 / otherRelZ) * (1 - dist3D / 1.5) * 0.4;
                
                ctx.strokeStyle = `${currentDomain.secondary}${Math.floor(lineOpacity * 255).toString(16).padStart(2, '0')}`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(otherScreenX, otherScreenY);
                ctx.stroke();
              }
            });
          });

          portalsRef.current.forEach(portal => {
            const relX = portal.x - cameraPos.x;
            const relY = portal.y - cameraPos.y;
            const relZ = portal.z - cameraPos.z;
            if (relZ <= 0.5) return;

            const scale = 400 / relZ;
            const screenX = centerX + relX * scale;
            const screenY = centerY + relY * scale;
            const size = portal.config.size * scale / 3;
            const opacity = Math.min(1, 4 / relZ);

            const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, size * 1.5);
            gradient.addColorStop(0, `${portal.config.color}${Math.floor(opacity * 60).toString(16).padStart(2, '0')}`);
            gradient.addColorStop(1, `${portal.config.color}00`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size * 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.save();
            ctx.translate(screenX, screenY);
            
            if (portal.config.type === 'cube') {
              const rotation = Date.now() * 0.001;
              ctx.rotate(rotation);
              ctx.strokeStyle = `${portal.config.color}${Math.floor(opacity * 255).toString(16).padStart(2, '0')}`;
              ctx.lineWidth = 2;
              ctx.strokeRect(-size/2, -size/2, size, size);
              ctx.strokeRect(-size/3, -size/3, size * 2/3, size * 2/3);
            } else if (portal.config.type === 'sphere') {
              const pulse = Math.sin(Date.now() * 0.003) * 0.2 + 1;
              ctx.strokeStyle = `${portal.config.color}${Math.floor(opacity * 255).toString(16).padStart(2, '0')}`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, size * pulse * 0.5, 0, Math.PI * 2);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(0, 0, size * pulse * 0.7, 0, Math.PI * 2);
              ctx.stroke();
            } else if (portal.config.type === 'pyramid') {
              const float = Math.sin(Date.now() * 0.002) * 5;
              ctx.strokeStyle = `${portal.config.color}${Math.floor(opacity * 255).toString(16).padStart(2, '0')}`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, -size/2 + float);
              ctx.lineTo(-size/2, size/2 + float);
              ctx.lineTo(size/2, size/2 + float);
              ctx.closePath();
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(0, -size/3 + float);
              ctx.lineTo(-size/3, size/3 + float);
              ctx.lineTo(size/3, size/3 + float);
              ctx.closePath();
              ctx.stroke();
            }
            ctx.restore();

            const distance = Math.sqrt(relX * relX + relY * relY + relZ * relZ);
            if (distance < 3) {
              ctx.fillStyle = `${portal.config.color}${Math.floor(opacity * 200).toString(16).padStart(2, '0')}`;
              ctx.font = `${12 * scale / 2}px 'Orbitron', monospace`;
              ctx.textAlign = 'center';
              ctx.fillText(distance < 2 ? 'ENTER' : '···', screenX, screenY + size + 20 * scale / 2);
            }
          });

          animationId = requestAnimationFrame(animate);
        };
        animate();

        return () => {
          cancelAnimationFrame(animationId);
          window.removeEventListener('resize', resize);
        };
      }, [cameraPos, currentDomain]);

      const handleCanvasClick = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        const centerX = canvasRef.current.width / 2;
        const centerY = canvasRef.current.height / 2;

        portalsRef.current.forEach(portal => {
          const relX = portal.x - cameraPos.x;
          const relY = portal.y - cameraPos.y;
          const relZ = portal.z - cameraPos.z;
          if (relZ <= 0.5) return;

          const scale = 400 / relZ;
          const screenX = centerX + relX * scale;
          const screenY = centerY + relY * scale;
          const size = portal.config.size * scale / 3;
          const dist = Math.sqrt(Math.pow(clickX - screenX, 2) + Math.pow(clickY - screenY, 2));
          
          if (dist < size) handlePortalClick(portal);
        });
      };

      return (
        <div style={{
          width: '100vw', height: '100vh', margin: 0, padding: 0,
          overflow: 'hidden', background: currentDomain.bg, position: 'relative',
          cursor: 'none', transition: 'background 1s cubic-bezier(0.4, 0, 0.2, 1)',
          fontFamily: "'Orbitron', 'Courier New', monospace"
        }}>
          <style>{`
            @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
            * { cursor: none !important; }
            @keyframes pulse {
              0%, 100% { opacity: 0; }
              50% { opacity: 1; }
            }
          `}</style>

          <canvas ref={canvasRef} onClick={handleCanvasClick} style={{
            position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
            opacity: transitioning ? 0.3 : 1, transition: 'opacity 0.8s ease'
          }} />

          <div style={{
            position: 'absolute', top: '40px', left: '50%', transform: 'translateX(-50%)',
            fontSize: '11px', fontWeight: '400', letterSpacing: '6px',
            color: currentDomain.accent, opacity: 0.4, textTransform: 'uppercase',
            textShadow: `0 0 10px ${currentDomain.accent}`
          }}>{currentDomain.name}</div>

          <div style={{
            position: 'absolute', top: '70px', left: '50%', transform: 'translateX(-50%)',
            fontSize: '9px', fontWeight: '300', letterSpacing: '3px',
            color: currentDomain.primary, opacity: 0.3, textTransform: 'uppercase'
          }}>move mouse to navigate</div>

          <div style={{
            position: 'absolute', bottom: '40px', left: '50%', transform: 'translateX(-50%)',
            fontSize: '13px', fontWeight: '700', letterSpacing: '8px',
            color: currentDomain.primary, opacity: 0.5, textTransform: 'uppercase',
            textShadow: `0 0 15px ${currentDomain.primary}`
          }}>Songs for the Simulation</div>

          <div style={{
            position: 'fixed', top: `${mousePos.y * 100}vh`, left: `${mousePos.x * 100}vw`,
            width: '8px', height: '8px', border: `1px solid ${currentDomain.accent}`,
            borderRadius: '50%', pointerEvents: 'none', transform: 'translate(-50%, -50%)',
            zIndex: 10000, boxShadow: `0 0 10px ${currentDomain.accent}`
          }}>
            <div style={{
              position: 'absolute', top: '50%', left: '50%', width: '2px', height: '2px',
              background: currentDomain.accent, borderRadius: '50%', transform: 'translate(-50%, -50%)'
            }} />
          </div>

          {transitioning && (
            <div style={{
              position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
              background: `radial-gradient(circle, ${currentDomain.bg}00 0%, ${currentDomain.bg} 100%)`,
              zIndex: 100, opacity: 1, animation: 'pulse 0.8s ease-in-out'
            }} />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SimulationSpaces />);
  </script>
</body>
</html>
